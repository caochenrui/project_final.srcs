
0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x07, 0xf0,0x03, 0xc0, 0x1f, 0xe0, 0x0f, 0xe0, 0x00, 0x78, 0x07, 0xfe, 0x00, 0xfe, 0x3f, 0xfe, 0x0f, 0xf0, 0x0f, 0xf0, 
0x1f, 0xf8,0x0f, 0xc0, 0x3f, 0xf8, 0x3f, 0xf0, 0x00, 0xf8, 0x07, 0xfc, 0x01, 0xfc, 0x3f, 0xfe, 0x1f, 0xf8, 0x1e, 0xf8, 
0x3e, 0x7c,0x1f, 0xc0, 0x3f, 0xf8, 0x3f, 0xf8, 0x01, 0xf8, 0x0f, 0xfc, 0x07, 0xe0, 0x7f, 0xfe, 0x3c, 0x3c, 0x3c, 0x7c, 
0x3c, 0x3c,0x03, 0xc0, 0x78, 0xfc, 0x70, 0xf8, 0x01, 0xf8, 0x1e, 0x00, 0x0f, 0xc0, 0x70, 0x1c, 0x38, 0x1c, 0x78, 0x3c, 
0x7c, 0x3e,0x03, 0xc0, 0x70, 0x7c, 0x60, 0x78, 0x03, 0xf8, 0x1c, 0x00, 0x1f, 0x80, 0xe0, 0x1c, 0x78, 0x1c, 0x78, 0x3e, 
0x78, 0x1e,0x03, 0xc0, 0x60, 0x3c, 0x00, 0x78, 0x07, 0xf8, 0x3f, 0x80, 0x1f, 0x00, 0x00, 0x3c, 0x7c, 0x3c, 0x78, 0x1e, 
0x78, 0x1e,0x03, 0xc0, 0x00, 0x3c, 0x00, 0x78, 0x0f, 0x78, 0x3f, 0xe0, 0x3e, 0x00, 0x00, 0x38, 0x3e, 0x3c, 0x78, 0x1e, 
0x78, 0x1e,0x03, 0xc0, 0x00, 0x3c, 0x00, 0xf0, 0x0e, 0x78, 0x3f, 0xf0, 0x3c, 0x00, 0x00, 0x38, 0x3f, 0x78, 0x78, 0x1e, 
0xf8, 0x1f,0x03, 0xc0, 0x00, 0x3c, 0x01, 0xe0, 0x1e, 0x78, 0x07, 0xf8, 0x7f, 0xf8, 0x00, 0x78, 0x1f, 0xf0, 0x78, 0x1e, 
0xf8, 0x1f,0x03, 0xc0, 0x00, 0x78, 0x07, 0xf0, 0x3c, 0x78, 0x01, 0xfc, 0x7f, 0xfc, 0x00, 0x70, 0x0f, 0xe0, 0x7c, 0x1e, 
0xf8, 0x1f,0x03, 0xc0, 0x00, 0x70, 0x0f, 0xf8, 0x78, 0x78, 0x00, 0x7c, 0x7c, 0x7e, 0x00, 0xf0, 0x07, 0xf0, 0x7e, 0x3e, 
0xf8, 0x1f,0x03, 0xc0, 0x00, 0xf0, 0x03, 0xfc, 0x70, 0x78, 0x00, 0x3c, 0x78, 0x3e, 0x00, 0xf0, 0x0f, 0xf8, 0x3f, 0xfe, 
0xf8, 0x1f,0x03, 0xc0, 0x01, 0xe0, 0x00, 0xfc, 0xe0, 0x78, 0x00, 0x3c, 0x78, 0x1e, 0x00, 0xe0, 0x1c, 0xfc, 0x1f, 0xfe, 
0x78, 0x1e,0x03, 0xc0, 0x01, 0xc0, 0x00, 0x7c, 0xff, 0xff, 0x00, 0x1c, 0x78, 0x1f, 0x01, 0xe0, 0x3c, 0x7c, 0x00, 0x3c, 
0x78, 0x1e,0x03, 0xc0, 0x03, 0x80, 0x00, 0x3c, 0xff, 0xff, 0x00, 0x1c, 0x78, 0x1f, 0x01, 0xe0, 0x78, 0x3e, 0x00, 0x7c, 
0x78, 0x1e,0x03, 0xc0, 0x07, 0x00, 0x00, 0x3c, 0xff, 0xff, 0x00, 0x1c, 0x78, 0x1e, 0x01, 0xc0, 0x78, 0x1e, 0x00, 0xf8, 
0x7c, 0x3e,0x03, 0xc0, 0x0e, 0x00, 0x00, 0x3c, 0x00, 0x78, 0x00, 0x3c, 0x7c, 0x1e, 0x03, 0xc0, 0x78, 0x1e, 0x00, 0xf8, 
0x3c, 0x3c,0x03, 0xc0, 0x1c, 0x06, 0x00, 0x38, 0x00, 0x78, 0x30, 0x78, 0x3c, 0x1e, 0x03, 0xc0, 0x7c, 0x1e, 0x01, 0xf0, 
0x3e, 0x7c,0x03, 0xc0, 0x3f, 0xfe, 0x78, 0x78, 0x00, 0x78, 0x7c, 0xf0, 0x3e, 0x3c, 0x03, 0x80, 0x3c, 0x3c, 0x07, 0xe0, 
0x1f, 0xf8,0x07, 0xe0, 0x7f, 0xfe, 0x7f, 0xf0, 0x00, 0x78, 0x7f, 0xe0, 0x1f, 0x78, 0x07, 0x80, 0x3f, 0x7c, 0x3f, 0x80, 
0x0f, 0xf0,0x1f, 0xf8, 0xff, 0xfc, 0x7f, 0xc0, 0x00, 0x78, 0x7f, 0xc0, 0x0f, 0xf0, 0x07, 0x80, 0x0f, 0xf0, 0x7f, 0x00, 
0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00;



S1:原始状态,等待开始信号进入S2
S2:产生新的方块
S3:保持状态,不动 没有信号则一段时间后自动S4 否则S7
S4:将方块下降一格 可以则S5,不可以则S6
S5:用于更新方块的坐标位置,返回S3
S6:判断是否可以消去,重复直至没有可消去
S7:快速下落与旋转
S8:更新屏幕
S9:结束 回到S1



`timescale 1ns / 1ps
module key(
    input clk,
    input rst_n,
    input UP_KEY,
    input LEFT_KEY,
    input RIGHT_KEY,
    input DOWN_KEY,
    output reg rotate,
    output reg left,
    output reg right,
    output reg down
    );
    
    reg [3:0] shift_up;
    reg [3:0] shift_left;
    reg [3:0] shift_right;
    reg [3:0] shift_down;
    
    always @(posedge clk or negedge rst_n)
    begin
        if (!rst_n)
            shift_up <= 0;
        else
            shift_up <= {shift_up[2:0], UP_KEY};
    end
    
    always @(posedge clk or negedge rst_n)
    begin
        if (!rst_n)
            shift_right <= 0;
        else
            shift_right <= {shift_right[2:0], RIGHT_KEY};
    end 
    
    always @(posedge clk or negedge rst_n)
    begin
        if (!rst_n)
            shift_left <= 0;
        else
            shift_left <= {shift_left[2:0], LEFT_KEY};
    end
    
    always @(posedge clk or negedge rst_n)
    begin
        if (!rst_n)
            shift_down <= 0;
        else
            shift_down <= {shift_down[2:0], DOWN_KEY};
    end


reg clk_div;
reg [7:0] clk_cnt;
always @ (posedge clk or negedge rst_n)
begin
    if (!rst_n)
    begin
        clk_cnt <= 0;
        clk_div <= 0;
    end
    else if (clk_cnt <= 8'd49)
    begin
        clk_cnt <= clk_cnt + 1;
        clk_div <= clk_div;
    end
    else
    begin
        clk_cnt <= 0;
        clk_div <= ~clk_div;
    end
end

always @(posedge clk_div or negedge rst_n)
begin
    if (!rst_n)
    begin
        rotate <= 0;
        left <= 0;
        right <= 0;
        down <= 0;
    end
    else
    begin
        rotate <= shift_up[3];
        left <= shift_left[3];
        right <= shift_right[3];
        down <= shift_down[3];
    end
end

endmodule


控制模块程序
module game_control_unit (
    input clk,
    input rst_n,
    input rotate,
    input left,
    input right,
    input down,
    input start,
    output reg [3:0] opcode,
    output reg gen_random,
    output reg hold,
    output reg shift,
    output reg move_down,
    output reg remove_1,
    output reg remove_2,
    output reg stop,
    output reg move,
    output reg isdie,
    output reg auto_down,
    input shift_finish,
    input remove_2_finish,
    input down_comp,
    input move_comp,
    input die
    );
    
    reg left_reg;
    reg right_reg;
    reg up_reg;
    reg down_reg;
    
    always @(posedge clk or negedge rst_n)
    begin
        if (!rst_n)
        begin
            left_reg <= 0;
            right_reg <= 0;
            up_reg <= 0;
            down_reg <= 0;
        end
        else
        begin
            left_reg <= left;
            right_reg <= right;
            up_reg <= rotate;
            down_reg <=  down;
        end
    end
    
    reg auto_down_reg;
    always @ (posedge clk or negedge rst_n)
    begin
        if (!rst_n)
            auto_down_reg <= 0;
        else if (time_cnt == time_val)
            auto_down_reg <= 1;
        else 
            auto_down_reg <= 0;
    end
    
    always @ (posedge clk or negedge rst_n)
    begin
        if (!rst_n)
            auto_down <= 0;
        else
            auto_down <= auto_down_reg;
    end
    
    parameter time_val = 26'd25000001;
    reg [25:0] time_cnt;

    localparam  S_idle      = 4'd0,
                S_new       = 4'd1,
                S_hold      = 4'd2,
                S_move      = 4'd3,
                S_shift     = 4'd4,
                S_down      = 4'd5,
                S_remove_1  = 4'd6,
                S_remove_2  = 4'd7,
                S_isdie     = 4'd8,
                S_stop      = 4'd9;

    reg [3:0] state, next_state;

    always @(posedge clk or negedge rst_n)
    begin
        if (!rst_n)
            state <= S_idle;
        else
            state <= next_state;
    end
    


    always @ (posedge clk or negedge rst_n)
    begin
        if (!rst_n)
            time_cnt <= 0;
        else if (hold == 0 && time_cnt < time_val)
            time_cnt <= time_cnt + 1;
        else if (move_down == 1)
            time_cnt <= 0;
        else begin
            time_cnt <= time_cnt;
        end
    end
    always @ (posedge clk or negedge rst_n)
    begin
        if (!rst_n) opcode<=0;
        else opcode<={right, left, down, rotate};
    end 
        

    always @ (*)
    begin
        next_state = S_idle;
        hold = 1;
        gen_random = 0;
        //opcode = 4'b0000;
        shift = 0;
        move_down = 0;
        remove_1 = 0;
        remove_2 = 0;
        stop = 0;
        move = 0;
        isdie = 0;
        case (state)
        S_idle:
        begin
            if (start)
                next_state = S_new;
            else
                next_state = S_idle;
        end
        S_new:
        begin
            gen_random = 1;
            next_state = S_hold;
        end
        S_hold:
        begin
            hold = 0;
            if (time_cnt == time_val)
            begin
                next_state = S_down;
            end
            else if ((down_reg == 0) && (down == 1))
            begin
               next_state = S_down;
            end
            else if ((left_reg == 0 && left == 1)|| ( right_reg == 0 && right == 1)||(up_reg == 0 && rotate == 1))
            begin
                next_state = S_move;
            end
            else
                next_state = S_hold;
        end
        S_move:
        begin
            move = 1;
            if (move_comp)
                next_state = S_shift;
            else
                next_state = S_hold;
        end
        S_shift:
        begin
            shift = 1;
            next_state = S_hold;
        end
        S_down:
        begin
            move_down = 1;
            if (down_comp)
                next_state = S_shift;
            else
                next_state = S_remove_1;                
        end
        S_remove_1:
        begin
            remove_1 = 1;
            next_state = S_remove_2;
        end
        S_remove_2:
        begin
            remove_2 = 1;
            if (remove_2_finish)
                next_state = S_isdie;
            else
                next_state = S_remove_2;
        end
        S_isdie:
        begin
            isdie = 1;
            if (die == 1)
                next_state = S_stop;
            else
                next_state = S_new;
        end
        S_stop:
        begin
            stop = 1;
            next_state = S_idle;
        end
        default next_state = S_idle;
        endcase
    end
    
endmodule



数据路径
module Datapath_Unit #(
    parameter   A_1 = 7'b0001000,
                B_1 = 7'b0011000,
                B_2 = 7'b0010100,
                B_3 = 7'b0010010,
                B_4 = 7'b0010001,
                C_1 = 7'b0101000,
                C_2 = 7'b0100100,
                C_3 = 7'b0100010,
                C_4 = 7'b0100001,
                D_1 = 7'b0111000,
                D_2 = 7'b0110100,
                E_1 = 7'b1001000,
                E_2 = 7'b1000100,
                E_3 = 7'b1000010,
                E_4 = 7'b1000001,
                F_1 = 7'b1011000,
                F_2 = 7'b1010100,
                G_1 = 7'b1101000,
                G_2 = 7'b1100100
    )(
    output reg MOVE_ABLE,SHIFT_FINISH,DOWN_ABLE,DIE_TRUE,
    output     [239:0] M_OUT,
    output reg [4:0] n,
    output reg [3:0] m,
    output reg [6:0] BLOCK,
    //output reg REMOVE_1_FINISH,
    output reg REMOVE_2_FINISH,
    //output reg NEW_BLOCK,
   
    input clk,rst_n,MOVE,DOWN,DIE,SHIFT,REMOVE_1,REMOVE_2,NEW,STOP,AUTODOWN,
    input [3:0] KEYBOARD
    );

    reg [2:0] RAN;
    reg [9:0] R [23:0];
    reg [6:0] NEW_BLOCK;
    reg [6:0] BLOCK_P;
    reg [4:0] remove_cnt;
    reg [3:0] REMOVE_2_S;
    reg [3:0] REMOVE_FINISH;
    reg [4:0] REMOVE_2_C;
    reg       SIG;

    always @ (posedge clk or negedge rst_n)
    begin
        if (!rst_n) 
            RAN<=0;
        else if (RAN==7) RAN<=1;
        else RAN<=RAN+1;
    end 

    // MOVE_ABLE signal
    always @ (*)
    begin
        MOVE_ABLE = 0;
        if (MOVE)
        begin
            if (KEYBOARD[0])  //UP
            begin
               // MOVE_ABLE=1;
                case (BLOCK)
                A_1: MOVE_ABLE=0;
                B_1: if (m>=1)
                        begin if (!((R[n][m-1])|(R[n][m+1])|(R[n-1][m+1]))) MOVE_ABLE=1; else MOVE_ABLE=0;end
                B_2: if (n<=22)
                        begin if (!((R[n+1][m-1])|(R[n+1][m])|(R[n-1][m]))) MOVE_ABLE=1; else MOVE_ABLE=0;end
                B_3: if (m<=8)
                        begin if (!(R[n][m-1] | R[n][m+1] | R[n+1][m-1])) MOVE_ABLE=1; else MOVE_ABLE=0;      end   
                B_4:    begin if (!((R[n-1][m])|(R[n+1][m])|(R[n+1][m+1]))) MOVE_ABLE=1; else MOVE_ABLE=0;end
                C_1: if (m<=8)
                        begin if (!((R[n][m-1])|(R[n][m+1])|(R[n+1][m+1]))) MOVE_ABLE=1; else MOVE_ABLE=0;end
                C_2:    begin if (!((R[n-1][m])|(R[n-1][m+1])|(R[n-1][m]))) MOVE_ABLE=1; else MOVE_ABLE=0;end
                C_3: if (m>=1)
                        begin if (!((R[n-1][m-1])|(R[n][m-1])|(R[n][m+1]))) MOVE_ABLE=1; else MOVE_ABLE=0;end
                C_4: if (n<=22)
                        begin if (!((R[n-1][m])|(R[n+1][m-1])|(R[n+1][m]))) MOVE_ABLE=1; else MOVE_ABLE=0;end
                D_1: if ((m>=1)&(m<=7))
                        begin if (!((R[n][m-1])|(R[n][m+1])|(R[n][m+2]))) MOVE_ABLE=1; else MOVE_ABLE=0;end
                D_2: if (n<=21)
                        begin if (!((R[n-1][m])|(R[n+1][m])|(R[n+2][m]))) MOVE_ABLE=1; else MOVE_ABLE=0;end
                E_1: if (n<=22)
                        begin if (!(R[n+1][m])) MOVE_ABLE=1; else MOVE_ABLE=0;end
                E_2: if (m<=8)
                        begin if (!(R[n][m+1])) MOVE_ABLE=1; else MOVE_ABLE=0;end
                E_3:    begin if (!(R[n-1][m])) MOVE_ABLE=1; else MOVE_ABLE=0;end
                E_4: if (m>=1)
                        begin if (!(R[n][m-1])) MOVE_ABLE=1; else MOVE_ABLE=0;end
                F_1: if (m>=1)
                        begin if (!((R[n-1][m-1])|(R[n-1][m]))) MOVE_ABLE=1; else MOVE_ABLE=0;end
                F_2: if (n<=22)
                        begin if (!((R[n-1][m+1])|(R[n+1][m]))) MOVE_ABLE=1; else MOVE_ABLE=0;end
                G_1: if (m>=1)
                        begin if (!((R[n-1][m+1])|(R[n][m-1]))) MOVE_ABLE=1; else MOVE_ABLE=0;end
                G_2: if (n<=22)
                        begin if (!((R[n][m+1])|(R[n+1][m+1]))) MOVE_ABLE=1; else MOVE_ABLE=0;end
                default MOVE_ABLE=0;
                endcase 
            end
            else if (KEYBOARD[2])  //LEFT
            begin
             //     MOVE_ABLE<=0;
                case (BLOCK)
                A_1: if (m>=1) if (!((R[n+1][m-1])|(R[n][m-1]))) MOVE_ABLE=1; else MOVE_ABLE=0;
                B_1: if (m>=1) if (!((R[n-1][m-1])|(R[n][m-1])|(R[n+1][m-1]))) MOVE_ABLE=1; else MOVE_ABLE=0;
                B_2: if (m>=2) if (!((R[n][m-1])|(R[n-1][m]))) MOVE_ABLE=1; else MOVE_ABLE=0;
                B_3: if (m>=2) if (!((R[n-1][m-2])|(R[n][m-1])|(R[n+1][m-1]))) MOVE_ABLE=1; else MOVE_ABLE=0;
                B_4: if (m>=2) if (!((R[n][m-2])|(R[n+1][m-2]))) MOVE_ABLE=1; else MOVE_ABLE=0;
                C_1: if (m>=2) if (!((R[n-1][m-1])|(R[n][m-1])|(R[n+1][m-2]))) MOVE_ABLE=1; else MOVE_ABLE=0;
                C_2: if (m>=2) if (!((R[n][m-2])|(R[n+1][m]))) MOVE_ABLE=1; else MOVE_ABLE=0;
                C_3: if (m>=1) if (!((R[n-1][m-1])|(R[n][m-1])|(R[n+1][m-1]))) MOVE_ABLE=1; else MOVE_ABLE=0;
                C_4: if (m>=2) if (!((R[n-1][m-2])|(R[n][m-2]))) MOVE_ABLE=1; else MOVE_ABLE=0;
                D_1: if (m>=1) if (!((R[n-1][m-1])|(R[n][m-1])|(R[n+1][m-1])|(R[n+2][m-1]))) MOVE_ABLE=1; else MOVE_ABLE=0;
                D_2: if (m>=2) if (!(R[n][m-2])) MOVE_ABLE=1; else MOVE_ABLE=0;
                E_1: if (m>=2) if (!((R[n-1][m-1])|(R[n][m-2]))) MOVE_ABLE=1; else MOVE_ABLE=0;
                E_2: if (m>=2) if (!((R[n-1][m-1])|(R[n][m-2])|(R[n+1][m-1])))    MOVE_ABLE=1; else MOVE_ABLE=0;
                E_3: if (m>=2) if (!((R[n][m-2])|(R[n+1][m-1]))) MOVE_ABLE=1; else   MOVE_ABLE=0;
                E_4: if (m>=1) if (!((R[n-1][m-1])|(R[n][m-1])|(R[n+1][m-1])))    MOVE_ABLE=1; else MOVE_ABLE=0;
                F_1: if (m>=1) if (!((R[n-1][m])|(R[n][m-1])|(R[n+1][m-1])))  MOVE_ABLE=1; else MOVE_ABLE=0;
                F_2: if (m>=2) if (!((R[n-1][m-2])|(R[n][m-1]))) MOVE_ABLE=1; else   MOVE_ABLE=0;
                G_1: if (m>=1) if (!((R[n-1][m-1])|(R[n][m-1])|(R[n+1][m-1])))    MOVE_ABLE=1; else MOVE_ABLE=0;
                G_2: if (m>=2) if (!((R[n-1][m-1])|(R[n][m-2]))) MOVE_ABLE=1; else   MOVE_ABLE=0;
                default MOVE_ABLE=0;
                endcase
            end
            else if (KEYBOARD[3])  //RIGHT
            begin
                //MOVE_ABLE=1;   
                case (BLOCK)
                A_1: if (m<=7) if (!((R[n+1][m+2])|(R[n][m+2]))) MOVE_ABLE=1; else   MOVE_ABLE=0;
                B_1: if (m<=7) if (!((R[n+1][m+2])|(R[n][m+1])|(R[n-1][m+1])))    MOVE_ABLE=1; else MOVE_ABLE=0;
                B_2: if (m<=7) if (!((R[n][m+2])|(R[n+1][m+2]))) MOVE_ABLE=1; else   MOVE_ABLE<=0;
                B_3: if (m<=8) if (!((R[n-1][m+1])|(R[n][m+1])|(R[n+1][m+1])))    MOVE_ABLE=1; else MOVE_ABLE=0;
                B_4: if (m<=7) if (!((R[n][m+2])|(R[n+1][m]))) MOVE_ABLE=1; else     MOVE_ABLE=0;
                C_1: if (m<=8) if (!((R[n-1][m+1])|(R[n][m+1])|(R[n+1][m+1])))    MOVE_ABLE=1; else MOVE_ABLE=0;
                C_2: if (m<=7) if (!((R[n-1][m+2])|(R[n][m+2]))) MOVE_ABLE=1; else   MOVE_ABLE=0;
                C_3: if (m<=7) if (!((R[n-1][m+2])|(R[n][m+1])|(R[n+1][m+1])))    MOVE_ABLE=1; else MOVE_ABLE=0;
                C_4: if (m<=7) if (!((R[n-1][m])|(R[n][m+2]))) MOVE_ABLE=1; else     MOVE_ABLE=0;
                D_1: if (m<=8) if (!((R[n-1][m+1])|(R[n][m+1])|(R[n+1][m+1])|(R[n+2][m+1]))) MOVE_ABLE=1; else MOVE_ABLE=0;
                D_2: if (m<=6) if (!(R[n][m+3])) MOVE_ABLE=1; else MOVE_ABLE=0;
                E_1: if (m<=7) if (!((R[n-1][m+1])|(R[n][m+2]))) MOVE_ABLE=1; else   MOVE_ABLE=0;
                E_2: if (m<=8) if (!((R[n-1][m+1])|(R[n][m+1])|(R[n+1][m+1])))    MOVE_ABLE=1; else MOVE_ABLE=0;
                E_3: if (m<=7) if (!((R[n][m+2])|(R[n+1][m+1]))) MOVE_ABLE=1; else   MOVE_ABLE=0;
                E_4: if (m<=7) if (!((R[n-1][m+1])|(R[n][m+2])|(R[n+1][m+1])))    MOVE_ABLE=1; else MOVE_ABLE=0;
                F_1: if (m<=7) if (!((R[n-1][m+2])|(R[n][m+2])|(R[n+1][m+1])))    MOVE_ABLE=1; else MOVE_ABLE=0;
                F_2: if (m<=7) if (!((R[n-1][m+1])|(R[n][m+2]))) MOVE_ABLE=1; else   MOVE_ABLE=0;
                G_1: if (m<=7) if (!((R[n-1][m+1])|(R[n][m+2])|(R[n+1][m+2])))    MOVE_ABLE=1; else MOVE_ABLE=0;
                G_2: if (m<=7) if (!((R[n-1][m+2])|(R[n][m+1]))) MOVE_ABLE=1; else   MOVE_ABLE=0;
                default MOVE_ABLE=0;
                endcase
            end
        end
        else
            MOVE_ABLE = 0;
    end

    // M_OUT
    assign M_OUT = {R[23],R[22],R[21],R[20],R[19],R[18],R[17],R[16],R[15],R[14],R[13],R[12],R[11],R[10],R[9],R[8],R[7],R[6],R[5],R[4],R[3],R[2],R[1],R[0]};

    // R
    integer i,j;
    always @ (posedge clk or negedge rst_n)
    begin
        if (!rst_n)
            begin
                for (i = 0; i < 24; i = i + 1) R[i] <= 0;
                REMOVE_FINISH<=0;
            end
        else if (REMOVE_1)
        begin
            case (BLOCK)
            A_1: begin R[n][m]<=1;R[n][m+1]<=1;R[n+1][m]<=1;R[n+1][m+1]<=1;end
            B_1: begin R[n-1][m]<=1;R[n][m]<=1;R[n+1][m]<=1;R[n+1][m+1]<=1;end
            B_2: begin R[n-1][m+1]<=1;R[n][m-1]<=1;R[n][m]<=1;R[n][m+1]<=1;end
            B_3: begin R[n-1][m-1]<=1;R[n-1][m]<=1;R[n][m]<=1;R[n+1][m]<=1;end 
            B_4: begin R[n][m-1]<=1;R[n][m]<=1;R[n][m+1]<=1;R[n+1][m-1]<=1;end
            C_1: begin R[n-1][m]<=1;R[n][m]<=1;R[n+1][m]<=1;R[n+1][m-1]<=1;end
            C_2: begin R[n][m-1]<=1;R[n][m]<=1;R[n][m+1]<=1;R[n+1][m+1]<=1;end
            C_3: begin R[n-1][m]<=1;R[n-1][m+1]<=1;R[n][m]<=1;R[n+1][m]<=1;end
            C_4: begin R[n-1][m-1]<=1;R[n][m-1]<=1;R[n][m]<=1;R[n][m+1]<=1;end
            D_1: begin R[n-1][m]<=1;R[n][m]<=1;R[n+1][m]<=1;R[n+2][m]<=1;end
            D_2: begin R[n][m-1]<=1;R[n][m]<=1;R[n][m+1]<=1;R[n][m+2]<=1;end
            E_1: begin R[n-1][m]<=1;R[n][m-1]<=1;R[n][m]<=1;R[n][m+1]<=1;end
            E_2: begin R[n-1][m]<=1;R[n][m-1]<=1;R[n][m]<=1;R[n+1][m]<=1;end
            E_3: begin R[n][m-1]<=1;R[n][m]<=1;R[n][m+1]<=1;R[n+1][m]<=1;end
            E_4: begin R[n-1][m]<=1;R[n][m]<=1;R[n][m+1]<=1;R[n+1][m]<=1;end
            F_1: begin R[n-1][m+1]<=1;R[n][m]<=1;R[n][m+1]<=1;R[n+1][m]<=1;end
            F_2: begin R[n-1][m-1]<=1;R[n-1][m]<=1;R[n][m]<=1;R[n][m+1]<=1;end
            G_1: begin R[n-1][m]<=1;R[n][m]<=1;R[n][m+1]<=1;R[n+1][m+1]<=1;end
            G_2: begin R[n-1][m]<=1;R[n-1][m+1]<=1;R[n][m-1]<=1;R[n][m]<=1;end
            default
            begin
                for (i = 0; i < 24; i = i + 1)
                    R[i] <= R[i];
            end
            endcase
            REMOVE_2_S<=4'b1111;
        end
        else if (REMOVE_2)
        begin
            if (!REMOVE_FINISH[0])
            begin if ((&R[n-1])|(SIG))
                begin
                    if (REMOVE_2_S[0]) begin REMOVE_2_C<=n-1; REMOVE_2_S[0]<=0; SIG<=1;end
                    else begin
                        if (REMOVE_2_C>=1) begin R[REMOVE_2_C]<=R[REMOVE_2_C-1]; REMOVE_2_C<=REMOVE_2_C-1; SIG<=1;end
                        else begin REMOVE_FINISH[0]<=1;SIG<=0;end
                    end
                end
            else begin REMOVE_FINISH[0]<=1; SIG<=0; end
            end    
            else if (!REMOVE_FINISH[1])
            begin if ((&R[n])|(SIG))
                begin
                    if (REMOVE_2_S[1]) begin REMOVE_2_C<=n; REMOVE_2_S[1]<=0; SIG<=1; end
                    else begin
                        if (REMOVE_2_C>=1) begin R[REMOVE_2_C]<=R[REMOVE_2_C-1]; REMOVE_2_C<=REMOVE_2_C-1; SIG<=1; end
                        else begin REMOVE_FINISH[1]<=1; SIG<=0; end
                    end
                end
            else begin REMOVE_FINISH[1]<=1; SIG<=0; end
            end
            else if (!REMOVE_FINISH[2])
            begin
            if (n<=22)
                begin if ((&R[n+1])|(SIG))
                    begin
                        if (REMOVE_2_S[2]) begin REMOVE_2_C<=n+1; REMOVE_2_S[2]<=0;SIG<=1; end
                        else begin
                            if (REMOVE_2_C>=1) begin R[REMOVE_2_C]<=R[REMOVE_2_C-1]; REMOVE_2_C<=REMOVE_2_C-1; SIG<=1; end
                            else begin REMOVE_FINISH[2]<=1; SIG<=0; end
                        end
                    end
                    else begin REMOVE_FINISH[2]<=1; SIG<=0; end
                end
            else begin REMOVE_FINISH[2]<=1; SIG<=0; end
            end    
            else if (!REMOVE_FINISH[3])
            begin
            if (n<=21)
                begin if ((&R[n+2])|(SIG))
                    begin
                        if (REMOVE_2_S[3]) begin REMOVE_2_C<=n+2; REMOVE_2_S[3]<=0; SIG<=1; end
                        else begin
                            if (REMOVE_2_C>=1) begin R[REMOVE_2_C]<=R[REMOVE_2_C-1]; REMOVE_2_C<=REMOVE_2_C-1; SIG<=1; end
                            else begin REMOVE_FINISH[3]<=1; SIG<=1; end
                        end
                    end
                    else begin REMOVE_FINISH[3]<=1; SIG<=0; end
                end
           else begin REMOVE_FINISH[3]<=1; SIG<=0; end    
           end
          else
            begin
            for (i=0; i <24; i = i + 1) R[i] <= R[i];
            REMOVE_FINISH<=0;
            SIG<=0;
            end
     end
     else if (STOP) for (i=0;i<=23;i=i+1) R[i]<=0;
end

    //BLOCK_P
    always @ (*)
    begin
        case (BLOCK)
        A_1: BLOCK_P = A_1;
        B_1: BLOCK_P = B_2;
        B_2: BLOCK_P = B_3;
        B_3: BLOCK_P = B_4;
        B_4: BLOCK_P = B_1;
        C_1: BLOCK_P = C_2;
        C_2: BLOCK_P = C_3;
        C_3: BLOCK_P = C_4;
        C_4: BLOCK_P = C_1;
        D_1: BLOCK_P = D_2;
        D_2: BLOCK_P = D_1;
        E_1: BLOCK_P = E_2;
        E_2: BLOCK_P = E_3;
        E_3: BLOCK_P = E_4;
        E_4: BLOCK_P = E_1;
        F_1: BLOCK_P = F_2;
        F_2: BLOCK_P = F_1;
        G_1: BLOCK_P = G_2;
        G_2: BLOCK_P = G_1;
        default BLOCK_P = 7'b0000000;
        endcase
    end

    // BLOCK
    always @ (posedge clk or negedge rst_n)
    begin
        if (!rst_n)
            BLOCK <= 7'b0000000;
        else if (NEW)
            BLOCK <= NEW_BLOCK;
        else if (SHIFT && KEYBOARD[0])
            BLOCK <= BLOCK_P;
        else
            BLOCK <= BLOCK;
    end

    // DOWN_ABLE
    always @ (*)
    begin
      //  if (!rst_n)
        DOWN_ABLE = 0;
        if (DOWN)
        begin
            //DOWN_ABLE<=1;
            case (BLOCK)
            A_1: if (n<=21) begin if (!(R[n+2][m] | R[n+2][m+1])) DOWN_ABLE = 1; else DOWN_ABLE = 0; end else DOWN_ABLE=0;
            B_1: if (n<=21) begin if (!(R[n+2][m] | R[n+2][m+1])) DOWN_ABLE = 1; else DOWN_ABLE = 0; end else DOWN_ABLE=0;
            B_2: if (n<=22) begin if (!(R[n+1][m] | R[n+1][m-1] | R[n+1][m+1])) DOWN_ABLE = 1; else DOWN_ABLE = 0; end else DOWN_ABLE=0;
            B_3: if (n<=21) begin if (!(R[n+2][m] | R[n][m-1])) DOWN_ABLE = 1; else DOWN_ABLE = 0; end else DOWN_ABLE=0;
            B_4: if (n<=21) begin if (!(R[n+1][m] | R[n+1][m+1] | R[n+2][m-1])) DOWN_ABLE = 1; else DOWN_ABLE = 0; end else DOWN_ABLE=0;
            C_1: if (n<=21) begin if (!(R[n+2][m] | R[n+2][m-1])) DOWN_ABLE = 1; else DOWN_ABLE = 0; end else DOWN_ABLE=0;
            C_2: if (n<=21) begin if (!(R[n+1][m] | R[n+1][m-1] | R[n+2][m+1])) DOWN_ABLE = 1; else DOWN_ABLE = 0; end else DOWN_ABLE=0;
            C_3: if (n<=21) begin if (!(R[n+2][m] | R[n][m+1])) DOWN_ABLE = 1; else DOWN_ABLE = 0; end else DOWN_ABLE=0;
            C_4: if (n<=22) begin if (!(R[n+1][m] | R[n+1][m-1] | R[n+1][m+1])) DOWN_ABLE = 1; else DOWN_ABLE = 0; end else DOWN_ABLE=0;
            D_1: if (n<=20) begin if (!(R[n+3][m])) DOWN_ABLE = 1; else DOWN_ABLE = 0; end else DOWN_ABLE=0;
            D_2: if (n<=22) begin if (!(R[n+1][m] | R[n+1][m-1] | R[n+1][m+1] | R[n+1][m+1])) DOWN_ABLE = 1; else DOWN_ABLE = 0; end else DOWN_ABLE=0;
            E_1: if (n<=22) begin if (!(R[n+1][m] | R[n+1][m-1] | R[n+1][m+1])) DOWN_ABLE = 1; else DOWN_ABLE = 0; end else DOWN_ABLE=0;
            E_2: if (n<=21) begin if (!(R[n+2][m] | R[n+1][m-1])) DOWN_ABLE = 1; else DOWN_ABLE = 0; end else DOWN_ABLE=0;
            E_3: if (n<=21) begin if (!(R[n+2][m] | R[n+1][m-1] | R[n+1][m+1])) DOWN_ABLE = 1; else DOWN_ABLE = 0; end else DOWN_ABLE=0;
            E_4: if (n<=21) begin if (!(R[n+2][m] | R[n+1][m+1])) DOWN_ABLE = 1; else DOWN_ABLE = 0; end else DOWN_ABLE=0;
            F_1: if (n<=21) begin if (!(R[n+2][m] | R[n+1][m+1])) DOWN_ABLE = 1; else DOWN_ABLE = 0; end else DOWN_ABLE=0;
            F_2: if (n<=22) begin if (!(R[n+1][m] | R[n][m-1] | R[n+1][m+1])) DOWN_ABLE = 1; else DOWN_ABLE = 0; end else DOWN_ABLE=0;
            G_1: if (n<=21) begin if (!(R[n+1][m] | R[n+2][m+1])) DOWN_ABLE = 1; else DOWN_ABLE = 0; end else DOWN_ABLE=0;
            G_2: if (n<=22) begin if (!(R[n+1][m] | R[n+1][m-1] | R[n][m+1])) DOWN_ABLE = 1; else DOWN_ABLE = 0; end else DOWN_ABLE=0;
            default DOWN_ABLE = 0;
            endcase
        end
        else
            DOWN_ABLE = 0;
    end

    // n
    always @ (posedge clk or negedge rst_n)
    begin
        if (!rst_n)
            n <= 0;
        else if (NEW)
            n <= 1;
        else if ((SHIFT)&(AUTODOWN))
            n<=n+1;
        else if ((SHIFT)&(KEYBOARD[1]))
            n <= n + 1;
        else
            n <= n;
    end

    // m
    always @ (posedge clk or negedge rst_n)
    begin
        if (!rst_n)
            m <= 0;
        else if (NEW)
            m <= 5;
        else if (SHIFT)
        begin
            if (AUTODOWN) m<=m;
            else if (KEYBOARD[2])
                m <= m - 1;
            else if (KEYBOARD[3])
                m <= m + 1;
            else
                m <= m;
        end
        else
            m <= m;
    end

    // NEW_BLOCK
    always @(*)
    begin
        if (!rst_n)
            NEW_BLOCK = A_1;
        else if (NEW)
        begin
            case (RAN)
            1: NEW_BLOCK = A_1;
            2: NEW_BLOCK = B_1;
            3: NEW_BLOCK = C_1;
            4: NEW_BLOCK = D_1;
            5: NEW_BLOCK = E_1;
            6: NEW_BLOCK = F_1;
            7: NEW_BLOCK = G_1;
            default NEW_BLOCK = A_1;
            endcase
        end
        else
            NEW_BLOCK = A_1;
    end

    // SHIFT_FINISH
    always @(posedge clk or negedge rst_n)
    begin
        if (!rst_n)
            SHIFT_FINISH <= 0;
        else if (SHIFT)
            SHIFT_FINISH <= 1;
        else
            SHIFT_FINISH <= 0;
    end
    // REMOVE_2_FINISH
    always @(posedge clk or negedge rst_n)
    begin
        if (!rst_n)
            REMOVE_2_FINISH <= 0;
        else if (&REMOVE_FINISH)
            REMOVE_2_FINISH <= 1;
        else
            REMOVE_2_FINISH <= 0;
    end

    // remove_cnt
    always @(posedge clk or negedge rst_n)
    begin
        if (!rst_n)
            remove_cnt <= 0;
        else if ((remove_cnt < 23) && (REMOVE_2 == 1))
            remove_cnt <= remove_cnt + 1;
        else
            remove_cnt <= 0;
    end

    // DIE_TRUE
    always @(*)
    begin
       if (DIE) begin
            if (|R[3]) DIE_TRUE = 1;
            else DIE_TRUE = 0;
       end
       else DIE_TRUE=0;
    end
    

endmodule


VGA模块
VGA_top.v
module top(
    clk,
    rst,
    number,
    hsync_r,
    vsync_r,
    OutRed,
    OutGreen,
    OutBlue);
    output hsync_r, vsync_r;
    output [3:0]OutRed, OutGreen;
    output [3:0]OutBlue;
    input  [199:0]number;
    input  clk,rst;
    
    wire clk_n;
    
    clk_unit myclk(
        .clk(clk),
        .rst(rst),
        .clk_n(clk_n)
    );

    VGA myvga(
        .hsync_r(hsync_r),
        .vsync_r(vsync_r),
        .OutRed(OutRed),
        .OutGreen(OutGreen),
        .OutBlue(OutBlue),
        .clk_n(clk_n),
        .rst(rst),
        .num(number)
    );

endmodule

clk_unit.v
module clk_unit(
    clk,
    rst,
    clk_n
    );
    input clk, rst;
    output clk_n;

    reg clk_n;
    reg clk_tmp;
    always @(posedge clk_tmp or posedge rst) begin
       if (rst) begin  
        clk_n <= 0;
       end
      else begin
        clk_n <= ~clk_n;
      end
    end
    
    always @(posedge clk or posedge rst)
    begin
        if (rst)
            clk_tmp <= 0;
        else
            clk_tmp <= ~clk_tmp;
    end
endmodule

VGA.v
module VGA(
  clk_n,
  rst,
  hsync_r,
  vsync_r,
  OutRed,
  OutGreen,
  OutBlue,
  num
  );
  input clk_n;
  input rst;
  input [199:0] num;
  output reg hsync_r;
  output reg vsync_r;
  output[3:0] OutRed;
  output[3:0] OutGreen;
  output[3:0] OutBlue;
  
  wire [9:0] R [19:0];
  assign R[0] = num[9:0];
  assign R[1] = num[19:10];
  assign R[2] = num[29:20];
  assign R[3] = num[39:30];
  assign R[4] = num[49:40];
  assign R[5] = num[59:50];
  assign R[6] = num[69:60];
  assign R[7] = num[79:70];
  assign R[8] = num[89:80];
  assign R[9] = num[99:90];
  assign R[10] = num[109:100];
  assign R[11] = num[119:110];
  assign R[12] = num[129:120];
  assign R[13] = num[139:130];
  assign R[14] = num[149:140];
  assign R[15] = num[159:150];
  assign R[16] = num[169:160];
  assign R[17] = num[179:170];
  assign R[18] = num[189:180];
  assign R[19] = num[199:190];
  
  reg[9:0]xsync,ysync;
  always @(posedge clk_n or posedge rst) begin
    if (rst) begin  
      xsync <= 10'd0;
    end
    else if (xsync == 10'd799) begin
      xsync <= 10'd0;
    end
    else begin
      xsync <= xsync + 1;
    end
  end

  always @(posedge clk_n or posedge rst) begin
    if (rst) begin
      ysync <= 10'd0;
    end
    else if (ysync == 10'd524) begin
      ysync <= 10'd0;
    end
    else if (xsync == 10'd799) begin
      ysync <= ysync + 1;
    end
  end
  
  always @(posedge clk_n or posedge rst) begin
    if (rst) begin
      hsync_r <= 1'b0;
    end
    else if (xsync == 799) begin
      hsync_r <=1'b0;
    end
    else if (xsync == 95) begin
      hsync_r <= 1'b1;
    end
  end

  always @(posedge clk_n or posedge rst) begin
    if (rst) begin
      vsync_r <= 1'b0;
    end
    else if (ysync == 0) begin
      vsync_r <=1'b0;
    end
    else if (ysync == 1) begin
      vsync_r <= 1'b1;
    end
  end
  
  wire valid;
  assign valid = (xsync > 143) && (xsync < 784) && (ysync > 34) && (ysync < 515);

  wire [9:0]x_pos, y_pos;
  assign x_pos = xsync - 143;
  assign y_pos = ysync -34;
  
wire [9:0] x;
wire [19:0] y;

assign x[0] = (x_pos >= 201) && (x_pos <= 224);
assign x[1] = (x_pos >= 225) && (x_pos <= 248);
assign x[2] = (x_pos >= 249) && (x_pos <= 272);
assign x[3] = (x_pos >= 273) && (x_pos <= 296);
assign x[4] = (x_pos >= 297) && (x_pos <= 320);
assign x[5] = (x_pos >= 321) && (x_pos <= 344);
assign x[6] = (x_pos >= 345) && (x_pos <= 368);
assign x[7] = (x_pos >= 369) && (x_pos <= 392);
assign x[8] = (x_pos >= 393) && (x_pos <= 416);
assign x[9] = (x_pos >= 417) && (x_pos <= 440);

assign y[0]  = (y_pos >= 1) && (y_pos <= 24); 
assign y[1]  = (y_pos >= 25) && (y_pos <= 48);
assign y[2]  = (y_pos >= 49) && (y_pos <= 72);
assign y[3]  = (y_pos >= 73) && (y_pos <= 96);
assign y[4]  = (y_pos >= 97) && (y_pos <=120);
assign y[5]  = (y_pos >= 121) && (y_pos <=144); 
assign y[6]  = (y_pos >= 145) && (y_pos <=168); 
assign y[7]  = (y_pos >= 169) && (y_pos <=192); 
assign y[8]  = (y_pos >= 193) && (y_pos <=216); 
assign y[9]  = (y_pos >= 217) && (y_pos <=240); 
assign y[10] = (y_pos >= 241) && (y_pos <=264); 
assign y[11] = (y_pos >= 265) && (y_pos <=288); 
assign y[12] = (y_pos >= 289) && (y_pos <=312); 
assign y[13] = (y_pos >= 313) && (y_pos <=336); 
assign y[14] = (y_pos >= 337) && (y_pos <=360); 
assign y[15] = (y_pos >= 361) && (y_pos <=384); 
assign y[16] = (y_pos >= 385) && (y_pos <=408); 
assign y[17] = (y_pos >= 409) && (y_pos <=432); 
assign y[18] = (y_pos >= 433) && (y_pos <=456); 
assign y[19] = (y_pos >= 457) && (y_pos <=480); 

//wire [9:0]R [19:0];
//assign R[0]  = 10'b0000000001;
//assign R[1]  = 10'b0000000101;
//assign R[2]  = 10'b0000010001;
//assign R[3]  = 10'b0001000001;
//assign R[4]  = 10'b0100000001;
//assign R[5]  = 10'b0100000001;
//assign R[6]  = 10'b0010000001;
//assign R[7]  = 10'b0001000001;
//assign R[8]  = 10'b0000100001;
//assign R[9]  = 10'b0000010001;
//assign R[10] = 10'b0000001001;
//assign R[11] = 10'b0000000101;
//assign R[12] = 10'b0000000011;
//assign R[13] = 10'b0000000001;
//assign R[14] = 10'b0000001001;
//assign R[15] = 10'b0000100001;
//assign R[16] = 10'b0100000001;
//assign R[17] = 10'b0000000001;
//assign R[18] = 10'b1111111111;
//assign R[19] = 10'b1010101010;

  parameter high = 12'b1111_1111_1111;
  reg [11:0] vga_rgb;
  
  //integer j, k;
  always @(posedge clk_n or posedge rst) begin
    if (rst) begin
      vga_rgb <= 0;
    end
    else if (valid)
    begin
        if (x_pos>=201 && x_pos<=440)
            if (x[0]&y[0]&R[0][0])
                vga_rgb <= high;
            else if (x[1] & y[0] &R[0][1])
                vga_rgb <= high;
            else if (x[2] & y[0] &R[0][2])
                vga_rgb <= high;            
            else if (x[3] & y[0] &R[0][3])
                 vga_rgb <= high;
            else if (x[4] & y[0] &R[0][4])
                 vga_rgb <= high;
            else if (x[5] & y[0] &R[0][5])
                 vga_rgb <= high;        
            else if (x[6] & y[0] &R[0][6])
                 vga_rgb <= high;
            else if (x[7] & y[0] &R[0][7])
                 vga_rgb <= high;
            else if (x[8] & y[0] & R[0][8])
                 vga_rgb <= high;
            else if (x[9] & y[0] & R[0][9])
                vga_rgb <= high;

            else if (x[0]&y[1]&R[1][0])
                vga_rgb <= high;
            else if (x[1] & y[1] &R[1][1])
                vga_rgb <= high;
            else if (x[2] & y[1] &R[1][2])
                vga_rgb <= high;            
            else if (x[3] & y[1] &R[1][3])
                 vga_rgb <= high;
            else if (x[4] & y[1] &R[1][4])
                 vga_rgb <= high;
            else if (x[5] & y[1] &R[1][5])
                 vga_rgb <= high;        
            else if (x[6] & y[1] &R[1][6])
                 vga_rgb <= high;
            else if (x[7] & y[1] &R[1][7])
                 vga_rgb <= high;
            else if (x[8] & y[1] & R[1][8])
                 vga_rgb <= high;
            else if (x[9] & y[1] & R[1][9])
                vga_rgb <= high;

            else if (x[0]&y[2]&R[2][0])
                vga_rgb <= high;
            else if (x[1] & y[2] &R[2][1])
                vga_rgb <= high;
            else if (x[2] & y[2] &R[2][2])
                vga_rgb <= high;            
            else if (x[3] & y[2] &R[2][3])
                 vga_rgb <= high;
            else if (x[4] & y[2] &R[2][4])
                 vga_rgb <= high;
            else if (x[5] & y[2] &R[2][5])
                 vga_rgb <= high;        
            else if (x[6] & y[2] &R[2][6])
                 vga_rgb <= high;
            else if (x[7] & y[2] &R[2][7])
                 vga_rgb <= high;
            else if (x[8] & y[2] & R[2][8])
                 vga_rgb <= high;
            else if (x[9] & y[2] & R[2][9])
                vga_rgb <= high;


            else if (x[0]&y[3]&R[3][0])
                vga_rgb <= high;
            else if (x[1] & y[3] &R[3][1])
                vga_rgb <= high;
            else if (x[2] & y[3] &R[3][2])
                vga_rgb <= high;            
            else if (x[3] & y[3] &R[3][3])
                 vga_rgb <= high;
            else if (x[4] & y[3] &R[3][4])
                 vga_rgb <= high;
            else if (x[5] & y[3] &R[3][5])
                 vga_rgb <= high;        
            else if (x[6] & y[3] &R[3][6])
                 vga_rgb <= high;
            else if (x[7] & y[3] &R[3][7])
                 vga_rgb <= high;
            else if (x[8] & y[3] & R[3][8])
                 vga_rgb <= high;
            else if (x[9] & y[3] & R[3][9])
                vga_rgb <= high;

            else if (x[0] & y[4] & R[4][0])
                vga_rgb <= high;
            else if (x[1] & y[4] &R[4][1])
                vga_rgb <= high;
            else if (x[2] & y[4] &R[4][2])
                vga_rgb <= high;            
            else if (x[3] & y[4] &R[4][3])
                 vga_rgb <= high;
            else if (x[4] & y[4] &R[4][4])
                 vga_rgb <= high;
            else if (x[5] & y[4] &R[4][5])
                 vga_rgb <= high;        
            else if (x[6] & y[4] &R[4][6])
                 vga_rgb <= high;
            else if (x[7] & y[4] &R[4][7])
                 vga_rgb <= high;
            else if (x[8] & y[4] & R[4][8])
                 vga_rgb <= high;
            else if (x[9] & y[4] & R[4][9])
                vga_rgb <= high;

            else if (x[0] &y[5] & R[5][0])
                vga_rgb <= high;
            else if (x[1] & y[5] & R[5][1])
                vga_rgb <= high;
            else if (x[2] & y[5] &R[5][2])
                vga_rgb <= high;            
            else if (x[3] & y[5] &R[5][3])
                 vga_rgb <= high;
            else if (x[4] & y[5] &R[5][4])
                 vga_rgb <= high;
            else if (x[5] & y[5] &R[5][5])
                 vga_rgb <= high;        
            else if (x[6] & y[5] &R[5][6])
                 vga_rgb <= high;
            else if (x[7] & y[5] &R[5][7])
                 vga_rgb <= high;
            else if (x[8] & y[5] & R[5][8])
                 vga_rgb <= high;
            else if (x[9] & y[5] & R[5][9])
                vga_rgb <= high;


            else if (x[0] & y[6] & R[6][0])
                vga_rgb <= high;
            else if (x[1] & y[6] & R[6][1])
                vga_rgb <= high;
            else if (x[2] & y[6] &R[6][2])
                vga_rgb <= high;            
            else if (x[3] & y[6] &R[6][3])
                 vga_rgb <= high;
            else if (x[4] & y[6] &R[6][4])
                 vga_rgb <= high;
            else if (x[5] & y[6] &R[6][5])
                 vga_rgb <= high;        
            else if (x[6] & y[6] &R[6][6])
                 vga_rgb <= high;
            else if (x[7] & y[6] &R[6][7])
                 vga_rgb <= high;
            else if (x[8] & y[6] & R[6][8])
                 vga_rgb <= high;
            else if (x[9] & y[6] & R[6][9])
                vga_rgb <= high;
            
            else if (x[0]&y[7]&R[7][0])
                vga_rgb <= high;
            else if (x[1] & y[7] &R[7][1])
                vga_rgb <= high;
            else if (x[2] & y[7] &R[7][2])
                vga_rgb <= high;            
            else if (x[3] & y[7] &R[7][3])
                 vga_rgb <= high;
            else if (x[4] & y[7] &R[7][4])
                 vga_rgb <= high;
            else if (x[5] & y[7] &R[7][5])
                 vga_rgb <= high;        
            else if (x[6] & y[7] &R[7][6])
                 vga_rgb <= high;
            else if (x[7] & y[7] &R[7][7])
                 vga_rgb <= high;
            else if (x[8] & y[7] & R[7][8])
                 vga_rgb <= high;
            else if (x[9] & y[7] & R[7][9])
                vga_rgb <= high;


            else if (x[0]&y[8]&R[8][0])
                vga_rgb <= high;
            else if (x[1] & y[8] &R[8][1])
                vga_rgb <= high;
            else if (x[2] & y[8] &R[8][2])
                vga_rgb <= high;            
            else if (x[3] & y[8] &R[8][3])
                 vga_rgb <= high;
            else if (x[4] & y[8] &R[8][4])
                 vga_rgb <= high;
            else if (x[5] & y[8] &R[8][5])
                 vga_rgb <= high;        
            else if (x[6] & y[8] &R[8][6])
                 vga_rgb <= high;
            else if (x[7] & y[8] &R[8][7])
                 vga_rgb <= high;
            else if (x[8] & y[8] & R[8][8])
                 vga_rgb <= high;
            else if (x[9] & y[8] & R[8][9])
                vga_rgb <= high;            


            else if (x[0]&y[9]&R[9][0])
                vga_rgb <= high;
            else if (x[1] & y[9] &R[9][1])
                vga_rgb <= high;
            else if (x[2] & y[9] &R[9][2])
                vga_rgb <= high;            
            else if (x[3] & y[9] &R[9][3])
                 vga_rgb <= high;
            else if (x[4] & y[9] &R[9][4])
                 vga_rgb <= high;
            else if (x[5] & y[9] &R[9][5])
                 vga_rgb <= high;        
            else if (x[6] & y[9] &R[9][6])
                 vga_rgb <= high;
            else if (x[7] & y[9] &R[9][7])
                 vga_rgb <= high;
            else if (x[8] & y[9] & R[9][8])
                 vga_rgb <= high;
            else if (x[9] & y[9] & R[9][9])
                vga_rgb <= high;

            else if (x[0]&y[10]&R[10][0])
                vga_rgb <= high;
            else if (x[1] & y[10] &R[10][1])
                vga_rgb <= high;
            else if (x[2] & y[10] &R[10][2])
                vga_rgb <= high;            
            else if (x[3] & y[10] &R[10][3])
                 vga_rgb <= high;
            else if (x[4] & y[10] &R[10][4])
                 vga_rgb <= high;
            else if (x[5] & y[10] &R[10][5])
                 vga_rgb <= high;        
            else if (x[6] & y[10] &R[10][6])
                 vga_rgb <= high;
            else if (x[7] & y[10] &R[10][7])
                 vga_rgb <= high;
            else if (x[8] & y[10] & R[10][8])
                 vga_rgb <= high;
            else if (x[9] & y[10] & R[10][9])
                vga_rgb <= high;

            else if (x[0]&y[11]&R[11][0])
                vga_rgb <= high;
            else if (x[1] & y[11] &R[11][1])
                vga_rgb <= high;
            else if (x[2] & y[11] &R[11][2])
                vga_rgb <= high;            
            else if (x[3] & y[11] &R[11][3])
                 vga_rgb <= high;
            else if (x[4] & y[11] &R[11][4])
                 vga_rgb <= high;
            else if (x[5] & y[11] &R[11][5])
                 vga_rgb <= high;        
            else if (x[6] & y[11] &R[11][6])
                 vga_rgb <= high;
            else if (x[7] & y[11] &R[11][7])
                 vga_rgb <= high;
            else if (x[8] & y[11] & R[11][8])
                 vga_rgb <= high;
            else if (x[9] & y[11] & R[11][9])
                vga_rgb <= high;

            else if (x[0]&y[12]&R[12][0])
                vga_rgb <= high;
            else if (x[1] & y[12] &R[12][1])
                vga_rgb <= high;
            else if (x[2] & y[12] &R[12][2])
                vga_rgb <= high;            
            else if (x[3] & y[12] &R[12][3])
                 vga_rgb <= high;
            else if (x[4] & y[12] &R[12][4])
                 vga_rgb <= high;
            else if (x[5] & y[12] &R[12][5])
                 vga_rgb <= high;        
            else if (x[6] & y[12] &R[12][6])
                 vga_rgb <= high;
            else if (x[7] & y[12] &R[12][7])
                 vga_rgb <= high;
            else if (x[8] & y[12] & R[12][8])
                 vga_rgb <= high;
            else if (x[9] & y[12] & R[12][9])
                vga_rgb <= high;


            else if (x[0]&y[13]&R[13][0])
                vga_rgb <= high;
            else if (x[1] & y[13] &R[13][1])
                vga_rgb <= high;
            else if (x[2] & y[13] &R[13][2])
                vga_rgb <= high;            
            else if (x[3] & y[13] &R[13][3])
                 vga_rgb <= high;
            else if (x[4] & y[13] &R[13][4])
                 vga_rgb <= high;
            else if (x[5] & y[13] &R[13][5])
                 vga_rgb <= high;        
            else if (x[6] & y[13] &R[13][6])
                 vga_rgb <= high;
            else if (x[7] & y[13] &R[13][7])
                 vga_rgb <= high;
            else if (x[8] & y[13] & R[13][8])
                 vga_rgb <= high;
            else if (x[9] & y[13] & R[13][9])
                vga_rgb <= high;

            else if (x[0] & y[14] & R[14][0])
                vga_rgb <= high;
            else if (x[1] & y[14] &R[14][1])
                vga_rgb <= high;
            else if (x[2] & y[14] &R[14][2])
                vga_rgb <= high;            
            else if (x[3] & y[14] &R[14][3])
                 vga_rgb <= high;
            else if (x[4] & y[14] &R[14][4])
                 vga_rgb <= high;
            else if (x[5] & y[14] &R[14][5])
                 vga_rgb <= high;        
            else if (x[6] & y[14] &R[14][6])
                 vga_rgb <= high;
            else if (x[7] & y[14] &R[14][7])
                 vga_rgb <= high;
            else if (x[8] & y[14] & R[14][8])
                 vga_rgb <= high;
            else if (x[9] & y[14] & R[14][9])
                vga_rgb <= high;

            else if (x[0] &y[15] & R[15][0])
                vga_rgb <= high;
            else if (x[1] & y[15] & R[15][1])
                vga_rgb <= high;
            else if (x[2] & y[15] &R[15][2])
                vga_rgb <= high;            
            else if (x[3] & y[15] &R[15][3])
                 vga_rgb <= high;
            else if (x[4] & y[15] &R[15][4])
                 vga_rgb <= high;
            else if (x[5] & y[15] &R[15][5])
                 vga_rgb <= high;        
            else if (x[6] & y[15] &R[15][6])
                 vga_rgb <= high;
            else if (x[7] & y[15] &R[15][7])
                 vga_rgb <= high;
            else if (x[8] & y[15] & R[15][8])
                 vga_rgb <= high;
            else if (x[9] & y[15] & R[15][9])
                vga_rgb <= high;


            else if (x[0] & y[16] & R[16][0])
                vga_rgb <= high;
            else if (x[1] & y[16] & R[16][1])
                vga_rgb <= high;
            else if (x[2] & y[16] &R[16][2])
                vga_rgb <= high;            
            else if (x[3] & y[16] &R[16][3])
                 vga_rgb <= high;
            else if (x[4] & y[16] &R[16][4])
                 vga_rgb <= high;
            else if (x[5] & y[16] &R[16][5])
                 vga_rgb <= high;        
            else if (x[6] & y[16] &R[16][6])
                 vga_rgb <= high;
            else if (x[7] & y[16] &R[16][7])
                 vga_rgb <= high;
            else if (x[8] & y[16] & R[16][8])
                 vga_rgb <= high;
            else if (x[9] & y[16] & R[16][9])
                vga_rgb <= high;
            
            else if (x[0]&y[17]&R[17][0])
                vga_rgb <= high;
            else if (x[1] & y[17] &R[17][1])
                vga_rgb <= high;
            else if (x[2] & y[17] &R[17][2])
                vga_rgb <= high;            
            else if (x[3] & y[17] &R[17][3])
                 vga_rgb <= high;
            else if (x[4] & y[17] &R[17][4])
                 vga_rgb <= high;
            else if (x[5] & y[17] &R[17][5])
                 vga_rgb <= high;        
            else if (x[6] & y[17] &R[17][6])
                 vga_rgb <= high;
            else if (x[7] & y[17] &R[17][7])
                 vga_rgb <= high;
            else if (x[8] & y[17] & R[17][8])
                 vga_rgb <= high;
            else if (x[9] & y[17] & R[17][9])
                vga_rgb <= high;


            else if (x[0]&y[18]&R[18][0])
                vga_rgb <= high;
            else if (x[1] & y[18] &R[18][1])
                vga_rgb <= high;
            else if (x[2] & y[18] &R[18][2])
                vga_rgb <= high;            
            else if (x[3] & y[18] &R[18][3])
                 vga_rgb <= high;
            else if (x[4] & y[18] &R[18][4])
                 vga_rgb <= high;
            else if (x[5] & y[18] &R[18][5])
                 vga_rgb <= high;        
            else if (x[6] & y[18] &R[18][6])
                 vga_rgb <= high;
            else if (x[7] & y[18] &R[18][7])
                 vga_rgb <= high;
            else if (x[8] & y[18] & R[18][8])
                 vga_rgb <= high;
            else if (x[9] & y[18] & R[18][9])
                vga_rgb <= high;            


            else if (x[0]&y[19]&R[19][0])
                vga_rgb <= high;
            else if (x[1] & y[19] &R[19][1])
                vga_rgb <= high;
            else if (x[2] & y[19] &R[19][2])
                vga_rgb <= high;            
            else if (x[3] & y[19] &R[19][3])
                 vga_rgb <= high;
            else if (x[4] & y[19] &R[19][4])
                 vga_rgb <= high;
            else if (x[5] & y[19] &R[19][5])
                 vga_rgb <= high;        
            else if (x[6] & y[19] &R[19][6])
                 vga_rgb <= high;
            else if (x[7] & y[19] &R[19][7])
                 vga_rgb <= high;
            else if (x[8] & y[19] & R[19][8])
                 vga_rgb <= high;
            else if (x[9] & y[19] & R[19][9])
                vga_rgb <= high;


            else
                vga_rgb <= 12'b0000_0000_1111;
         else
            vga_rgb <= 12'b0000_0000_0000;
    end
    else
    begin
      vga_rgb <= 0;
    end
end

  assign OutRed = vga_rgb[11:8];
  assign OutGreen = vga_rgb[7:4];
  assign OutBlue = vga_rgb[3:0];
endmodule


数据合并
merge.v
module merge #(
    parameter ROW = 20,
    parameter COL = 10
    )(
    input clk,
    input rst_n,
    input [(ROW+4)*COL-1:0] data_in,
    input [6:0] shape,
    input [3:0] x_pos,
    input [4:0] y_pos,
    output [ROW*COL-1:0] data_out
    );

    // latency = 2 period

    wire [8:0] loc;
    wire [8:0] left;
    wire [8:0] right;
    wire [8:0] up;
    wire [8:0] down;
    wire [8:0] up_left;
    wire [8:0] up_right;
    wire [8:0] down_left;
    wire [8:0] down_right;
    assign loc = y_pos*10+x_pos;
    assign left = loc - 1;
    assign right = loc + 1;
    assign up = loc - COL;
    assign down = loc + COL;
    assign up_left = up - 1;
    assign up_right = up + 1;
    assign down_left = down - 1;
    assign down_right = down + 1;

    localparam  A1 = 7'b0001000,
                B1 = 7'b0011000,
                B2 = 7'b0010100,
                B3 = 7'b0010010,
                B4 = 7'b0010001,
                C1 = 7'b0101000,
                C2 = 7'b0100100,
                C3 = 7'b0100010,
                C4 = 7'b0100001,
                D1 = 7'b0111000,
                D2 = 7'b0110100,
                E1 = 7'b1001000,
                E2 = 7'b1000100,
                E3 = 7'b1000010,
                E4 = 7'b1000001,
                F1 = 7'b1011000,
                F2 = 7'b1010100,
                G1 = 7'b1101000,
                G2 = 7'b1100100;

    reg [ROW*COL-1:0] data;
    reg [(ROW+4)*COL-1:0] merge_data;

    assign data_out = data | data_in[(ROW+4)*COL-1:40];
    //assign data_out = data | data_in[ROW*COL-1:0];
    
    always @ (posedge clk or negedge rst_n)
    begin
        if (!rst_n)
            data <= 0;
        else
            data <= merge_data[(ROW+4)*COL-1:40];
            //  data <= merge_data[ROW*COL-1:0];
    end

    always @ (*)
    begin
        merge_data = 0;
        case (shape)
        A1:
        begin
            merge_data[loc] = 1;
            merge_data[right] = 1;
            merge_data[down] = 1;
            merge_data[down_right] = 1;
        end 
        B1:
        begin
            merge_data[loc] = 1;
            merge_data[up] = 1;
            merge_data[down] = 1;
            merge_data[down_right] = 1;
        end
        B2:
        begin
            merge_data[loc] = 1;
            merge_data[left] = 1;
            merge_data[right] = 1;
            merge_data[up_right] = 1;
        end
        B3:
        begin
            merge_data[loc] = 1;
            merge_data[up] = 1;
            merge_data[up_left] = 1;
            merge_data[down] = 1;
        end
        B4:
        begin
            merge_data[loc] = 1;
            merge_data[left] = 1;
            merge_data[right] = 1;
            merge_data[down_left] = 1;
        end
        C1:
        begin
            merge_data[loc] = 1;
            merge_data[up] = 1;
            merge_data[down] = 1;
            merge_data[down_left] = 1;
        end
        C2:
        begin
            merge_data[loc] = 1;
            merge_data[left] = 1;
            merge_data[right] = 1;
            merge_data[down_right] = 1;
        end
        C3:
        begin
            merge_data[loc] = 1;
            merge_data[up] = 1;
            merge_data[down] = 1;
            merge_data[up_right] = 1;
        end
        C4:
        begin
            merge_data[loc] = 1;
            merge_data[left] = 1;
            merge_data[right] = 1;
            merge_data[up_left] = 1;
        end
        D1:
        begin
            merge_data[loc] = 1;
            merge_data[up] = 1;
            merge_data[down] = 1;
            merge_data[down+COL] = 1;
        end
        D2:
        begin
            merge_data[loc] = 1;
            merge_data[left] = 1;
            merge_data[right] = 1;
            merge_data[right+1] = 1;
        end
        E1:
        begin
            merge_data[loc] = 1;
            merge_data[left] = 1;
            merge_data[right] = 1;
            merge_data[up] = 1;
        end
        E2:
        begin
            merge_data[loc] = 1;
            merge_data[left] = 1;
            merge_data[down] = 1;
            merge_data[up] = 1;
        end
        E3:
        begin
            merge_data[loc] = 1;
            merge_data[down] = 1;
            merge_data[right] = 1;
            merge_data[left] = 1;
        end
        E4:
        begin
            merge_data[loc] = 1;
            merge_data[up] = 1;
            merge_data[down] = 1;
            merge_data[right] = 1;
        end
        F1:
        begin
            merge_data[loc] = 1;
            merge_data[up_right] = 1;
            merge_data[down] = 1;
            merge_data[right] = 1;
        end
        F2:
        begin
            merge_data[loc] = 1;
            merge_data[up] = 1;
            merge_data[up_left] = 1;
            merge_data[right] = 1;
        end
        G1:
        begin
            merge_data[loc] = 1;
            merge_data[up] = 1;
            merge_data[right] = 1;
            merge_data[down_right] = 1;
        end
        G2:
        begin
            merge_data[loc] = 1;
            merge_data[left] = 1;
            merge_data[up] = 1;
            merge_data[up_right] = 1;
        end
        default merge_data = 0;
        endcase
    end

endmodule


顶层模块
`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 2015/11/15 19:38:52
// Design Name: 
// Module Name: tetris
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////


module tetris #(
    parameter ROW = 20,
    parameter COL = 10
    )(
    input clk,
    input rst,
    input UP_KEY,
    input LEFT_KEY,
    input RIGHT_KEY,
    input DOWN_KEY,
    input start,
    output vsync_r,
    output hsync_r,
    output [3:0]OutRed, OutGreen,
    output [3:0]OutBlue
    );
    
    wire [3:0] opcode;
    wire gen_random;
    wire hold;
    wire shift;
    wire move_down;
    wire remove_1;
    wire remove_2;
    wire stop;
    wire move;
    wire isdie;
    wire shift_finish;
    wire down_comp;
    wire move_comp;
    wire die;
    wire [ROW*COL-1:0] data_out;
    
    wire [6:0] BLOCK;
    wire [3:0] m;
    wire [4:0] n;
    wire [(ROW+4)*COL-1:0] M_OUT;
    
    wire rotate;
    wire left;
    wire right;
    wire down;
    wire auto_down;
    wire rst_n;
    assign rst_n = ~rst;
    
    key u_key (
        .clk(clk),
        .rst_n(rst_n),
        .UP_KEY(UP_KEY),
        .LEFT_KEY(LEFT_KEY),
        .RIGHT_KEY(RIGHT_KEY),
        .DOWN_KEY(DOWN_KEY),
        .rotate(rotate),
        .left(left),
        .right(right),
        .down(down)
    );
    
    game_control_unit u_Controller (
        .clk(clk),
        .rst_n(rst_n),
        .rotate(rotate),
        .left(left),
        .right(right),
        .down(down),
        .start(start),
        .opcode(opcode),
        .gen_random(gen_random),
        .hold(hold),
        .shift(shift),
        .move_down(move_down),
        .remove_1(remove_1),
        .remove_2(remove_2),
        .stop(stop),
        .move(move),
        .isdie(isdie),
        .shift_finish(shift_finish),
        .down_comp(down_comp),
        .move_comp(move_comp),
        .die(die),
        .auto_down(auto_down),
        .remove_2_finish(remove_2_finish)
        );
        
    Datapath_Unit u_Datapath (
        .clk(clk),
        .rst_n(rst_n),
        .NEW(gen_random),
        .MOVE(move),
        .DOWN(move_down),
        .DIE(isdie),
        .SHIFT(shift),
        .REMOVE_1(remove_1),
        .REMOVE_2(remove_2),
        .KEYBOARD(opcode),
        .MOVE_ABLE(move_comp),
        .SHIFT_FINISH(shift_finish),
        .DOWN_ABLE(down_comp),
        .DIE_TRUE(die),
        .M_OUT(M_OUT),
        .n(n),
        .m(m),
        .BLOCK(BLOCK),
        .REMOVE_2_FINISH(remove_2_finish),
        .STOP(stop),
        .AUTODOWN(auto_down)
        );
        
    merge u_merge (
        .clk(clk),
        .rst_n(rst_n),
        .data_in(M_OUT),
        .shape(BLOCK),
        .x_pos(m),
        .y_pos(n),
        .data_out(data_out)
        
        );
     
    top u_VGA (
        .clk(clk),
        .rst(rst),
        .number(data_out),
        .hsync_r(hsync_r),
        .vsync_r(vsync_r),
        .OutRed(OutRed),
        .OutGreen(OutGreen),
        .OutBlue(OutBlue)        
    );
    
    
endmodule


module winORfail(

);

parameter S0 = 2'b00,
          S1 = 2'b01,
          S2 = 2'b10,
          S3 = 2'b11